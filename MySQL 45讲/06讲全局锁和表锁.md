# 06讲全局锁和表锁
> MySQL中锁大致分为全局锁,表级锁和行锁.本文主要讲锁实现的现象和背后的原因.不涉及实现细节.

## 全局锁
- 对整个数据库实例加锁
- 命令:`Flush tables with read lock(FTWRL)` 使得整个库处于只读状态
- 执行的时候会刷脏页的数据到磁盘,保证一致性
- 因此执行FTWRL的时候,所有的时候都提交完毕才会执行
- 数据更新（数据的增删改）、数据定义（包括建表、修改表结构 等）和更新类事务的提交语句都会被阻塞
- 典型使用场景,全库的逻辑备份,吧整个库每个表都select出来存为文本
- 让整个库只读存在的问题:
	- 主库上备份,备份期间不可以更新,业务基本就停了(冷备份)
	- 从库上备份,备份期间不可以执行主库同步过来的binlog,出现主从延迟
- 全库备份的时候依旧需要停止插入,防止出现不一致问题
- 全局锁,会锁住DML(增删改数据),同时也会锁住DDL(表结构操作)

### 可以采用RR的隔离级别实现online备份
- 自带的备份中举mysqldump使用参数`-single-transaction`时,就会使用RR的事务,来拿到一致性视图
- 这就是online备份的方法
- 一致性读,需要存储引擎的支持,因此如果使用不支持事务的引擎,依旧要用FTWRL命令

### set global readonly=true
- 一些系统中,readonly会被用来做其他逻辑,例如判断主库还是备库
- 发生异常时FTWRL命令,会在断开后自动释放全局锁.但是readonly则会使得全库处于只读
- readonly对super权限是无效的,依旧可以写入

## 表级锁
> 分为两种:表锁和元数据锁(meta data lock MDL)

### 表锁
- 语法是`lock tables ... read/write`
- 使用`unlock tables`主动释放,或者断开连接时自动释放
- 表锁回限定所有线程的读写操作
- 在不支持行锁的引擎中,表锁是常用的一种并发控制手段
- 当然InnoDB有行锁,所以表锁很少用到

### MDL 表锁(读写锁)
- 在访问表的时候会被自动加上
- 确保读写的原子性,正确性
- MySQL 5.5中引入该特性
- 对表做增删改查操作时,添加MDL读锁
- 对表做结构变更操作是,添加MDL写锁
- 读锁不互斥,多个线程可以支持增删改查
- 写锁互斥,即一个表结构变更时,其余所有线程都需要等待变更完成

#### Online DDL
- MySQL 5.6支持Online的表结构修改
- 过程为:
	1.  拿到MDL写锁
	2.  降级成MDL读锁
	3.  执行DDL
	4.  升级成MDL写锁
	5.  释放MDL锁
- 他依旧会先去拿写锁,如果1,2,4,5没有冲突执行会很迅速