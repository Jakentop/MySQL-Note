## MySQL中两个视图概念
- 一个是view.他是通过查询语句定义的虚拟表
	- 调用的时候执行该查询语句生成结果
	- `create view ...`语法
- 另一个是InnoDB在实现MVCC时用到的一致性视图
	- consistent read view
	- 用于支持隔离界别(RC,RR)
	- 作用是事务执行期间定义当前事务能看到的数据

## "快照"在MVCC中如何工作
- InnoDB中每一个事务都有一个唯一的事务ID(transaction id)
- 在事务开始时向InnoDB事务系统申请,按照顺序严格递增的
- InnoDB中每行数据有多个版本,每次更新都会生成一个新的数据版本
- **row trx_id**=transaction id
- ![](http://img.jaken.top/image/202111301532928.png)
- 可以看到此处有4个row trx_id,数据版本
- undo log便是U1,U2,U3;他对应了V1到V2的逆向操作 ^137642
- 注意V1,V2,V3并**不是物理存在**的,而是根据当前版本和undo log计算出来的

### 如何实现MVCC
- **InnoDB利用了所有数据都有多个版本,实现了秒级创建快照能力
- InnoDB为每个事务构造了一个数组,用来保存这个事务启动瞬间,当前活跃的所有事务ID
- 活跃即,事务启动了但是还没有提交
- 数组中事务ID的最小值记为低水位;
- 当前系统中已创建过的事务ID的最大值+1记为高水位
- 这个视图数组和高水位,就组成了当前事务的一致性视图
- ![](http://img.jaken.top/image/202111301543935.png)
- 当前事务启动瞬间,一个数据版本的row trx_id有以下情况:
	- 落在绿色部分,这个版本是已提交事务(可见)
	- 落在红色部分,这个版本是有后来启动的事务生成的(不可见)
	- 落在黄色部分:
		- row trx_id在数组中,这个版本是由没提交的事务生成的(不可见)
		- row trx_id不在数组中,这个版本是由已提交事务生成的(可见)

### 更新逻辑(当前读)
- 更新数据都是先读后写的,此时的读只能读到当前的值,被称为当前读
- 对于更新操作时的读取,会获取当前row trx_id中最新的数据,并更新
- 对于执行select for update或者lock in share mode语句时,也会使用当前读逻辑
- 当前读是会添加写锁的(X锁 排他锁),这会阻塞其他的X锁

### RR和RC是如何通过一致性读实现的
- RR级别可重复读,就只需要在事务开始时,创建一致性视图即可
- RC级别读已提交,就在每个语句执行前都算出一个新的视图数组