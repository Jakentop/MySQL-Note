
> [行锁](00tips.md#InnoDB行锁是通过锁索引实现的)是由各个引擎自己实现的,不是所有引擎都有[行锁](00tips.md#InnoDB行锁是通过锁索引实现的).行锁是对表中记录加的锁

## 两阶段锁
- 在InnoDB事务中,行锁在需要时被加上,只有在**事务结束**时才会被释放
- 因此如果某个事务要锁多行,可以吧**最可能影响并发**的锁放在事务后面
- 这样可以减少锁竞争时间

## 死锁和死锁检测
- 不同线程中出现循环资源依赖(A事务持有a等待b;B事务持有b等待a)
- 导致这几个线程进入无限等待状态(死锁)
- 两种解决死锁的策略:
	- 设置执行超时时间`innodb_lock_wait_timeout`,防止往死里等
	- 发起死锁检测设置参数`innodb_deadlock_detect=on`,主动回滚死锁链中某个事务

### 设置执行超时时间
- 在InnoDB中,	`innodb_lock_wait_timeout`默认值为50s
- 对于在线服务来说,这个时间是无法接收的
- 而这个时间也很难定(不可能太小,不然会误伤长查询)

### 主动死锁检测
- `innodb_deadlock_detect`本身就是开启的
- 这个操作的过程十分耗时O(n^2)级别的(最坏情况下)
	- 如果加锁访问的行上有锁就会开始死锁检测
	- 扫描与该锁相关的事务是否会形成死锁
	- 因此例如有1000条线程,则死锁检测是1000^2 百万级别的
	- 这会导致CPU资源利用率很高

### 比较好的思路
- 如果可以确保业务不会出现死锁,可以临时关闭死锁检测
- 通过控制并发度减少资源占用率
- 可以分散数据,优化数据库结构使其不容易出现高并发的行