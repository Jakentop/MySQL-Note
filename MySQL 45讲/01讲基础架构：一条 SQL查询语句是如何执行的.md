# 01讲基础架构：一条 SQL查询语句是如何执行的
## MySQL逻辑架构图
![](http://img.jaken.top/image/20211118212223.png)
MySQL分为Server层和存储引擎层(插件式存储引擎)
- Server层:连接器,查询缓存,分析器,优化器,执行器
	- 包括内置函数(日期,时间,数学,加密)
	- 存储过程,触发器,视图
	- 跨存储引擎都在此实现
- 存储引擎层:数据的存储和提取
	- 插件式的,支持InnoDB,MyISAM,Memory
	- MySQL 5.5.5开始InnoDB为默认存储引擎(建表是如果不选择默认为InnoDB)
## 连接器
> 连接器负责和客户端建立连接,获取权限,维持和管理链接.

### 连接过程
- 通过MySQL客户端工具和服务端建立连接
- 完成TCP握手后,连接器开始认证身份(通过用户名和密码)
- 用户名密码不正确,会受到一个"Access denied for user"的错误,然后执行结束
- 户名密码认证通过,**连接器会从权限表中拿出权限**,之后连接的权限逻辑判断都依赖于此
	- 连接建立后,管理员修改权限,也不会影响到已建立的权限
- 连接完成后,无后续动作就处于空闲状态
	- `show processlist`命令可以看到连接状态
	- `wait_timeout`参数控制太长时间没有动静就会断开连接,时间为8小时.(错误提示:Lost connection to MySQL server during query)

### 长连接,短连接;**建议使用长连接**,因为建立过程很复杂:
- 长连接:连接成功后客户端持续有请求,一直都是使用同一个连接
- 短连接:每次执行完就断开连接,下次查询再重建一个

### 长连接导致MySQL内存占用很高:
- MySQL中临时内存是管理在连接对象中的
- 只有断开连接才会释放临时内存资源
- 长连接过多,导致内存过大,被系统强行杀掉
- 解决方案
	- 定期断开长连接
	- 使用MySQL5.7或更高,可以执行mysql_reset_connection来重置连接字段.
	- 此过程不需要重连和重做权限验证

## 查询缓存(几乎不用了)
- 调用select语句后,会先查询查询缓存中是否有命中,如果有就直接返回缓存
- 缓存的形式为key-value(有点redis的味道)\[语句:结果]的格式
- 实际上不建议使用查询缓存
	- 只要对一个表更新,表缓存就会被清空
	- 命中率非常低
	- 只有在系统配置表中才建议使用(读场景很高)
- MySQL 8.0开始已经没有查询缓存了
- 按需使用查询缓存
	- 设置参数`query_cache_type=DEMAND`
	- 默认SQL语句都不使用查询缓存
	- 对于使用的可以通过`SQL_CACHE`来指定
	- `select SQL_CACHE * from T where ID=10；`

## 分析器
- 词法分析:识别SQL字符串中单词分别是什么代表什么
- 语法分析:拿到词法分析的结果,根据语法规则,判断输入的SQL是否满足语法
	- 如果正确语法分析会告诉你SQL的语法错误

## 优化器
- 语法分析后MySQL只要要做什么,随后就执行优化逻辑
- 选择那个索引,多表连接选择连接顺序
- 优化后,执行方案就确定了

## 执行器
- 开始执行时,会判断是否对操作表有对应权限,没有权限则报错,实际工程实现上:
	- 如果命中查询缓存,在返回缓存时验证权限
	- 也会在优化器之前调用precheck验证权限
	- 在执行器上做二次鉴权是因为,例如触发器等需要在执行阶段才能确定,因此只有在这里才可以做鉴权.
- 执行器根据表定义的引擎,去使用该引擎的接口:
	- 取表的一行,判断是否满足条件,不满足跳过,满足则放在结果集中
	- 循环到条件结束
- **rows_examined**引擎扫描行数,作为返回结果告诉用户Server访问了几次存储引擎
	- 这个结果不代表扫描的实际行数
	- 例如Server调用引擎拿一条数据,可能引擎内部扫描了多条,但是就返回了一条结果,Server层就只有一行