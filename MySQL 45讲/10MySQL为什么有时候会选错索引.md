## 优化器的逻辑
- 优化器会选择执行语句的最优索引(最小的代价执行语句;扫描行数;临时表;排序等因素)
- 扫描行数是通过统计信息来估算记录数的
- 这个统计信息就是索引的区分度;一个索引不同值越多,区分度就越好
- 基数:一个索引上不同值个数越大,索引区分度越好
- 查看基数:`show index from [table]`
- 如何计算索引基数
	- 通过采样统计,InnoDB会选择N个数据页,统计上面的不同值
	- 得出一个平均值,然后乘以索引页面数,就得到了这个索引的基数
	- MySQL中有两种索引统计方法,通过`innodb_stats_persistent` 来选择
		- 为on表示统计信息会持久化;此时N是20,M是10;
		- 为off表示统计信息只存储在内存中;此时N是8,M是16;
	- 当变更数据行超过1/M的时候会自动触发一次索引基数统计
- 使用普通索引(二级索引时)优化器还会考虑,回表的代价
- 也可以手动重新统计索引信息 `analyze table [table]`

### 解决优化器选错索引
- 采用 `force index` 强行选择一个索引
	- `select ... from [table] force index([index]) ...
	- 这样写就必须保证索引名字不能改
	- 这个不是标准SQL可能不兼容
- 修改语句,应道MySQL使用我们期望的索引
- 可以创建一个更合适的索引,或者删掉误用索引来提供优化器选择